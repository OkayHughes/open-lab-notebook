<!DOCTYPE html>
<html lang="en">
  <head>
    
    
    
    <meta charset="utf-8" />
    <link rel="icon" href="https://cdn.glitch.com/8af1b7af-efae-4a35-b1d7-e47b835582bc%2Fall_TMQ_moist_day5-1.ico?v=1630525741731" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Your new 11ty blog" />
    <link rel="stylesheet" type="text/css" href="/public/style.css" />
    <link rel="stylesheet" type="text/css" href="/public/fonts/cmu.css" />
    <link rel="stylesheet" href="https://unpkg.com/katex@latest/dist/katex.min.css" />
    
    <title>Open Lab Notebook</title>

<meta name="description" content="A blog which serves as my lab notebook, but which is visible to the world because I&apos;m a masochist.">
<meta name="robots" content="index,follow">
<meta name="author" content="undefined">

<link rel="canonical" href="https://undefined.glitch.me/posts/glass_project/code_outline/">

<meta property="og:title" content="Open Lab Notebook">
<meta property="og:type" content="article">

<meta property="og:url" content="https://undefined.glitch.me/posts/glass_project/code_outline/">
<meta property="og:description" content="A blog which serves as my lab notebook, but which is visible to the world because I&apos;m a masochist.">
<meta property="og:image" content="https://cdn.glitch.com/8af1b7af-efae-4a35-b1d7-e47b835582bc%2Fall_TMQ_moist_day5.png?v=1630525127233">

<meta name="twitter:card" content="summary">

<meta name="twitter:url" content="https://undefined.glitch.me/posts/glass_project/code_outline/">
<meta name="twitter:title" content="Open Lab Notebook">
<meta name="twitter:description" content="A blog which serves as my lab notebook, but which is visible to the world because I&apos;m a masochist.">
<meta name="twitter:image" content="https://cdn.glitch.com/8af1b7af-efae-4a35-b1d7-e47b835582bc%2Fall_TMQ_moist_day5.png?v=1630525127233">


  </head>
  <body>
  <main>
    
    
  
    


<div class="wrapper post">
  <div>
    
    <h1 class='postTitle'>Code outline</h1>

    
    
    
    <p>The locality of the <code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex"> H </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></code> matrix's components mean that the primary computational expense
is solving an extremely sparse matrix (each line of the system contains at most 4 non-zero entries on the LHS).</p>
<p>It is clear that formulation of the <code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex"> H </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></code> dynamic tangent matrix can be computed node-by-node in an embarassingly
parallel fashion.</p>
<p>Presumably the main implementation of these libraries will use the parMETIS algorithm for graph partitioning
and Trilinos NOX for nonlinear solvers.</p>
<p>This is a good example of how to do this in an MPI compliant fashion:
<a href="https://github.com/trilinos/Trilinos/blob/master/packages/nox/examples/epetra/NOX_1DFEMNonlinear/FiniteElementProblem.C">source</a></p>
<h2>Data input etc</h2>
<p>I'm going to make the assumption that input data will contain triangulation data. Might be worth creating a separate program
that reads OBJ + vertex data files so I can design initial setups in blender.</p>
<h3>necessary field data:</h3>
<p><em>Vertices:</em></p>
<ul>
<li>position</li>
<li>velocity</li>
<li>temperature</li>
<li>pressure?</li>
<li>iswall</li>
<li>isfree</li>
</ul>
<p><em>Tetrahedra:</em></p>
<ul>
<li>point ids</li>
<li>inlet_pressure (4 values per face)</li>
<li>placeholder (for boundary tracking)</li>
</ul>
<h3>Storage format:</h3>
<p>Let's use hdf5 because it seems relatively standardized and has parallel IO support.</p>
<p>Because all of this is kind of for artistic purposes, I'm going to default to single precision file storage.</p>
<p>Actually let us use https://cgns.github.io/CGNS_docs_current/index.html
because it feels suitable</p>
<details>
  <summary>parallel fileio example </summary>
<pre>
<code>
#include <stdio.h>
#include <stdlib.h>

#include "pcgnslib.h"
#include "mpi.h"

#define NODES_PER_SIDE 5

int main(int argc, char *argv[])
{
    int comm_size, comm_rank;
    int tot_nnodes, tot_nelems, nnodes, nelems;
    int F, B, Z, E, S, Fs, A, Cx, Cy, Cz;
    int i, j, k, n, nn, ne;
    float *x, *y, *z, *d;
    cgsize_t sizes[3], *e, start, end, ncells;
    static char *outfile = "cexample.cgns";

    /* initialize MPI */
    MPI_Init(&argc,&argv);
    MPI_Comm_size(MPI_COMM_WORLD, &comm_size);
    MPI_Comm_rank(MPI_COMM_WORLD, &comm_rank);

    /* total number of nodes and hex elements */
    tot_nnodes = NODES_PER_SIDE * NODES_PER_SIDE * NODES_PER_SIDE;
    tot_nelems = (NODES_PER_SIDE-1) * (NODES_PER_SIDE-1) * (NODES_PER_SIDE-1);
 
    /* open the file and create base and zone */
    sizes[0] = tot_nnodes;
    sizes[1] = tot_nelems;
    sizes[2] = 0;

    /* the default here is to use MPI_COMM_WORLD,
       but this allows assigning of another communicator
    cgp_mpi_comm(MPI_COMM_WORLD); */

    if (cgp_open(outfile, CG_MODE_WRITE, &F) ||
        cg_base_write(F, "Base", 3, 3, &B) ||
        cg_zone_write(F, B, "Zone", sizes, Unstructured, &Z))
        cgp_error_exit();

    /* print info */
    if (comm_rank == 0) {
        printf("writing %d coordinates and %d hex elements to %s\n",
            tot_nnodes, tot_nelems, outfile);
    }

    /* create data nodes for coordinates */
    if (cgp_coord_write(F, B, Z, RealSingle, "CoordinateX", &Cx) ||
        cgp_coord_write(F, B, Z, RealSingle, "CoordinateY", &Cy) ||
        cgp_coord_write(F, B, Z, RealSingle, "CoordinateZ", &Cz))
        cgp_error_exit();
 
    /* number of nodes and range this process will write */
    nnodes = (tot_nnodes + comm_size - 1) / comm_size;
    start  = nnodes * comm_rank + 1;
    end    = nnodes * (comm_rank + 1);
    if (end > tot_nnodes) end = tot_nnodes;
    
    /* create the coordinate data for this process */
    x = (float *)malloc(nnodes * sizeof(float));
    y = (float *)malloc(nnodes * sizeof(float));
    z = (float *)malloc(nnodes * sizeof(float));
    nn = 0;
    for (n = 1, k = 0; k < NODES_PER_SIDE; k++) {
        for (j = 0; j < NODES_PER_SIDE; j++) {
            for (i = 0; i < NODES_PER_SIDE; i++, n++) {
                if (n >= start && n <= end) {
                    x[nn] = (float)i;
                    y[nn] = (float)j;
                    z[nn] = (float)k;
                    nn++;
                }
            }
        }
    }

    /* write the coordinate data in parallel */
    if (cgp_coord_write_data(F, B, Z, Cx, &start, &end, x) ||
        cgp_coord_write_data(F, B, Z, Cy, &start, &end, y) ||
        cgp_coord_write_data(F, B, Z, Cz, &start, &end, z))
        cgp_error_exit();
    
    /* create data node for elements */
    if (cgp_section_write(F, B, Z, "Hex", HEXA_8, 1, tot_nelems, 0, &E))
        cgp_error_exit();
 
    /* number of elements and range this process will write */
    nelems = (tot_nelems + comm_size - 1) / comm_size;
    start  = nelems * comm_rank + 1;
    end    = nelems * (comm_rank + 1);
    if (end > tot_nelems) end = tot_nelems;
    
    /* create the hex element data for this process */
    e = (cgsize_t *)malloc(8 * nelems * sizeof(cgsize_t));
    nn = 0;
    for (n = 1, k = 1; k < NODES_PER_SIDE; k++) {
        for (j = 1; j < NODES_PER_SIDE; j++) {
            for (i = 1; i < NODES_PER_SIDE; i++, n++) {
                if (n >= start && n <= end) {
                    ne = i + NODES_PER_SIDE*((j-1)+NODES_PER_SIDE*(k-1));
                    e[nn++] = ne;
                    e[nn++] = ne + 1;
                    e[nn++] = ne + 1 + NODES_PER_SIDE;
                    e[nn++] = ne + NODES_PER_SIDE;
                    ne += NODES_PER_SIDE * NODES_PER_SIDE;
                    e[nn++] = ne;
                    e[nn++] = ne + 1;
                    e[nn++] = ne + 1 + NODES_PER_SIDE;
                    e[nn++] = ne + NODES_PER_SIDE;
                }
            }
        }
    }

    /* write the element connectivity in parallel */
    if (cgp_elements_write_data(F, B, Z, E, start, end, e))
        cgp_error_exit();

    /* create a centered solution */
    if (cg_sol_write(F, B, Z, "Solution", CellCenter, &S) ||
        cgp_field_write(F, B, Z, S, RealSingle, "CellIndex", &Fs))
        cgp_error_exit();

    /* create the field data for this process */
    d = (float *)malloc(nelems * sizeof(float));
    nn = 0;
    for (n = 1; n <= tot_nelems; n++) {
        if (n >= start && n <= end) {
            d[nn] = (float)n;
            nn++;
        }
    }

    /* write the solution field data in parallel */
    if (cgp_field_write_data(F, B, Z, S, Fs, &start, &end, d))
        cgp_error_exit();

    /* create user data under the zone and duplicate solution data */
    ncells = tot_nelems;
    if (cg_goto(F, B, "Zone_t", 1, NULL) ||
        cg_user_data_write("User Data") ||
        cg_gorel(F, "User Data", 0, NULL) ||
        cgp_array_write("CellIndex", RealSingle, 1, &ncells, &A))
        cgp_error_exit();

    /* write the array data in parallel */
    if (cgp_array_write_data(A, &start, &end, d))
        cgp_error_exit();

    /* close the file and terminate MPI */
    cgp_close(F);    
    MPI_Finalize();
    return 0;
}
  
</code>
</pre>
</details>
<h2>Start off with a serial implementation:</h2>
<p>First goal: no tracking or boundaries. Pure fluid solver without gravity (or oscillating gravity or something).</p>
<p>Define a spherical geometry with a pocket on the inside.</p>

    <div class="controls">

    
      
          <h3>
            Parent post:
      </h3>
          <ul><li><a href="/your-repo-name/posts/glass_project/glass_main/">Main Glass Post</a></li></ul>
      
      
      
      
      
    </div>
  </div>
</div>

      <footer class="footer">
        <div class="links">
          <a href="/">Home</a>
          <span class="divider">|</span>
          <a href="/posts">Posts</a>
          <span class="divider">|</span>
          <a href="/about">About</a>
        </div>
        <a class="btn--remix" target="_top" href="https://glitch.com/edit/#!/remix/glitch-hello-eleventy">
        <img src="https://cdn.glitch.com/605e2a51-d45f-4d87-a285-9410ad350515%2FLogo_Color.svg?v=1618199565140" alt="" /> 
        Remix on Glitch
        </a>
        <a class="btn--remix" target="_top" href="https://glitch.com/edit/#!/open-lab-notebook">
        Edit
        </a>
      </footer>
    
  </main>
   
  </body>
</html>